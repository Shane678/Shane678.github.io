---
title: ES6 Class 之操作方法
tags:
  - JavaScript
  - ES6
  - Class
categories:
  - 前端
author: Shane
img: >-
  https://myimagebed-1302088591.cos.ap-nanjing.myqcloud.com/%E6%96%87%E7%AB%A0%E7%89%B9%E5%BE%81%E5%9B%BE/26.jpg
top: true
toc: true
summary: ES5 和 ES6 中操作方法的区别
abbrlink: a52095f
date: 2020-07-12 22:43:47
---

## ES5 和 ES6 中操作方法的区别

操作一个方法，这里的“方法”包括：

1. 对象实例的方法
2. 类的静态方法

对象实例的方法之前已经讲过，这里不再赘述，下面主要讲下类的静态方法。

### 1. ES5

```javascript
/* ES5 中类的声明、实例对象的方法的声明、类的静态方法的声明 */
let Animal = function (type) {
  this.type = type
//   this.eat = function () {} // 实例对象的方法挂载在 this 上
}
Animal.prototype.eat = function () { // 实例对象的方法挂载在 prototype 上，即挂载到类的原型链上
  Animal.walk() // 调用静态方法 walk()，静态方法就是属于类的，调用时要用类名调用
  //   this.walk() // 调用实例对象的 walk() 方法，因为并不存在，所以会报错。this 表示实例对象
  console.log('eat food')
}
Animal.walk = function () { // 静态方法挂载在类上
  console.log('I am walking.')
}

let dog = new Animal('dog')
dog.eat()
dog.walk() // 报错！静态方法 walk() 在实例对象上是找不到的

/* 运行结果：
I am walking.
eat food
Uncaught TypeError: dog.walk is not a function
*/
```



### 2. ES6

ES6 中通过使用 static 定义类的静态方法。

```javascript
/* ES6 中类的声明、实例对象的方法的声明、类的静态方法的声明 */
class Animal {
  constructor (type) {
    this.type = type
  }
  // 定义实例对象的方法
  eat () {
    Animal.walk() // 调用静态方法 walk()，静态方法就是属于类的，调用时要用类名调用
    console.log('I am eating food...')
  }
  // 定义类的静态方法
  static walk () {
    console.log('walk walk')
  }
}
let dog = new Animal('dog')
dog.eat()

/* 运行结果：
walk walk
I am eating food...
*/
```

那么，在实际开发中，什么时候用实例对象的方法，什么时候用类的静态方法呢？这里可以给大家做一个小小的建议，如果说你的这个方法依赖于对象的某些属性或方法，那么此方法就必须定义为实例对象的方法，也就是说这个方法的内部要引用实例对象的一些信息；反之，如果说这个方法里面不会涉及到实例对象的内容，那就用类的静态方法。其实非常简单，类的静态方法拿不到当前的的实例对象。